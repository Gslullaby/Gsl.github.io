<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[scala中的函数]]></title>
    <url>%2F2018%2F07%2F23%2Fscala%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[在各类blog及scala书籍中看到的关于函数最多的一句话是 函数是一等公民 可以看出函数在scala中举足轻重的地位，因此很有必要去全面的掌握它 scala函数基础定义函数 匿名函数 12scala&gt; (x: Int) =&gt; x + 1res0: Int =&gt; Int = $$Lambda$1026/1792711692@7412ed6b 固定写法：左边是参数列表，中间符号=&gt;，右边是函数体匿名函数无函数名，也无需给出函数的结果类型 函数字面量 123scala&gt; val f = (x: Int) =&gt; x + 1scala&gt; f(10)res0: Int = 11 其中表达式有半部分为一个匿名函数，函数作为一个变量(或不变量)，用变量名+参数表方式调用，与普通方法的调用几乎相同。 需要注意的是函数字面量声明函数时不需要写出函数的返回值类型，函数体的最后一条表达式的结果会作为返回值返回 函数的本质scala不像java有基本类型与引用类型之分，scala中一切皆对象，包括函数也是对象。scala中定义了一系列trait，Function0 - Function22，其中0-22表示参数的个数(至于为什么是到22，理论上讲程序中不会出现多于22个参数的函数)。而函数正是Function的实例。如val f = (x: Int) =&gt; x + 1其实就是Function1的实例。下面看下Function的源码，以Function3为例123456789101112131415161718192021222324252627/** A function of 3 parameters. * */trait Function3[-T1, -T2, -T3, +R] extends AnyRef &#123; self =&gt; /** Apply the body of this function to the arguments. * @return the result of function application. */ def apply(v1: T1, v2: T2, v3: T3): R /** Creates a curried version of this function. * * @return a function `f` such that `f(x1)(x2)(x3) == apply(x1, x2, x3)` */ @annotation.unspecialized def curried: T1 =&gt; T2 =&gt; T3 =&gt; R = &#123; (x1: T1) =&gt; (x2: T2) =&gt; (x3: T3) =&gt; apply(x1, x2, x3) &#125; /** Creates a tupled version of this function: instead of 3 arguments, * it accepts a single [[scala.Tuple3]] argument. * * @return a function `f` such that `f((x1, x2, x3)) == f(Tuple3(x1, x2, x3)) == apply(x1, x2, x3)` */ @annotation.unspecialized def tupled: Tuple3[T1, T2, T3] =&gt; R = &#123; case Tuple3(x1, x2, x3) =&gt; apply(x1, x2, x3) &#125; override def toString() = "&lt;function3&gt;"&#125; 可以看到其中有一个apply方法(先忽略其他方法)，接受三个泛型参数，所以当我们调用f(1)时，其实是调用了Function1实例的apply方法。 函数与方法在学习过程中，还有一点很困扰，就是我们在类中用def定义的是不是函数，如果不是函数，它又是什么，跟函数又有什么区别呢？首先呢使用def 关键字定义的是方法，不是函数，虽然在实际应用中几乎没有差别，但还是需要了解两者的不同的 方法 定义在类中，作为某个对象的成员方法，使用def关键字定义12scala&gt; def a(x: Int):Int = x + 1a: (x: Int)Int 两者的区别 方法使用def关键字定义，而函数不用(函数使用val/var或干脆匿名) 方法是类的一部分，函数是对象可以赋值给一个val/var 函数作为对象可以像任何其他数据类型一样被传递和操作，而方法不行，如果想要传递方法，则需要把方法转换为函数 定义方法时，如果没有参数，则参数表可以省略不写(即方法名后不写())，而函数不行 定义函数时参数列表后不能声明结果类型，如下面的写法会编译错误1234scala&gt; f(x: Int):Int =&gt; x + 1&lt;console&gt;:1: error: ';' expected but '=&gt;' found. f(x: Int):Int =&gt; x + 1 ^ 两者的转换 第一种情况，方法直接转为函数不能将方法直接声明为一个val/var，如下面的写法会编译错误 123456scala&gt; def m(x: Int):Int = x + 1scala&gt; val f = m&lt;console&gt;:12: error: missing argument list for method mUnapplied methods are only converted to functions when a function type is expected.You can make this conversion explicit by writing `m _` or `m(_)` instead of `m`. val f = m 正确写法 123scala&gt; def m(x: Int):Int = x + 1scala&gt; val f = m _f: Int =&gt; Int = $$Lambda$1069/727861082@4990b335 这个转换的其实是使用了部分应用(Partial Applied Function)，下面将会讲到 第二种情况，需要函数的地方使用方法这种情况下不需要使用下划线，方法会被自动转换为函数，称之为eta转换。关于eta-expansion与eta-conversion的解释可以参考王宏江-scala中的eta-conversion与王宏江-再谈eta-conversion与eta-expansion scala函数进阶高阶函数引用维基百科中高阶函数的定义 在数学和计算机科学中，高阶函数是至少满足下列一个条件的函数： 接受一个或多个函数作为输入 输出一个函数 定义应该很容易理解，也就是函数可以接受另一个函数作为参数，或者函数的结果类型为函数类型。 第一种：如数学中的函数f(x) = x + 1， g(x) = x * 2，则f(g(x)) = (x * 2) + 1, 即为高阶函数。用代码实现即为 12def g(x: Int) = x * 2def f(x: Int, g: Int =&gt; Int) = g(x) + 1 第二种：结果类型为函数类型 1234def g(x: Int):(Int =&gt; Int) = &#123; val k = x * 2 (y: Int) =&gt; y + k + 1&#125; 函数的部分应用先看下代码如何实现函数的部分应用吧1234567891011121314scala&gt; def sum(x: Int, y: Int, z: Int) = x + y + zsum: (x: Int, y: Int, z: Int)Intscala&gt; val a = sum _a: (Int, Int, Int) =&gt; Int = $$Lambda$1055/565627330@309cedb6scala&gt; a(1,2,3)res0: Int = 6scala&gt; val b = sum(1, _: Int, _: Int)b: (Int, Int) =&gt; Int = $$Lambda$1060/605472344@6d5f4900scala&gt; b(2,3)res1: Int = 6 上面代码中出现了两种写法 写法一val a = sum _这行代码表示sum方法的三个参数都为给出，整个参数表都用占位符_代替，所以这行代码的效果其实就是讲方法sum转换为了函数a。与之相同的写法还有val a = sum(_) 写法二val b = sum(1, _: Int, _: Int)这行代码表示，已知三个参数中的x，y和z未给出，用占位符_代替，最后返回一个包含了两个参数的函数b 部分应用从数学角度理解比较容易，如上面例子中的sum，其实对应于数学中的sum(x,y,z) = x + y + z，这是一个三元函数(既有三个未知数)，而写法二对sum的部分应用，相当于我们现在得知x = 1，则带入函数得sum(y,z) = 1 + y + z，也就是函数f消去了未知元x。 整体来看函数的部分应用其实就是数学中的消元。 而写法是对未消去任何参数的一种简写 函数的柯里化在scala中函数函数可以有多个参数列表，而函数柯里化就是将函数的多参数列表转换为多个多参数列表。写法如下12345678910scala&gt; def sum(x: Int, y: Int) = x + ysum: (x: Int, y: Int)Intscala&gt; val a = sum _a: (Int, Int) =&gt; Int = $$Lambda$1075/571435580@5eb041b5scala&gt; val b = a.curriedb: Int =&gt; (Int =&gt; Int) = scala.Function2$$Lambda$1076/1263872787@524dd373scala&gt; 柯里化是通过调用函数对象的curried方法实现的。也就是说调用的是Function*中的curried方法(Function2-Function22拥有curried方法，Function0及Function1没有，因为无参函数和但参函数不需要也不能柯里化)，以Function2为例，我们看下源码的实现1234567trait Function2[-T1, -T2, +R] extends AnyRef &#123; self =&gt; ... @annotation.unspecialized def curried: T1 =&gt; T2 =&gt; R = &#123; (x1: T1) =&gt; (x2: T2) =&gt; apply(x1, x2) &#125; ...&#125; curried的实现是将一个多参函数转换为一个单参函数的函数链，对于上面的例子来说就是把sum(x,y)转换成了sum(x)(y)，sum(1)(2)也就是对两个单参函数的依次调用，而sum(1)或者sum(2)其实相当于对sum函数的部分应用，返回值是一个单参函数 写在最后关于scala中的函数，就先写这么多吧，等到后面开发应用到其他的知识，在作补充。关于函数的部分应用和柯里化的实际意义，在scala函数式编程那篇里写出来，这里就不写了]]></content>
      <categories>
        <category>scala</category>
      </categories>
      <tags>
        <tag>scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scala函数式编程]]></title>
    <url>%2F2018%2F07%2F21%2Fscala%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[从java转向scala已经有一段时间了，虽然平时写代码问题不大，但是因为面向对象编程已经根深蒂固了，所以一直对函数式编程理解不是很到位，需要抽空仔细学习并记录一下 什么是函数式函数式编程，不是某一种语言的特性，而是诸多编程思想(如命令式，面向对象等)中的一种。对于它的解释，我引用王宏江-Scala中的函数式特性中的一段话 图灵机，以及冯诺依曼对它的实现（冯诺依曼体系），从风格上被归为“命令式”，它的运算过程可以看作不断地修改内存来反映运算的结果，即用命令修改状态；而阿隆佐邱奇提出的 Lambda 演算，则是通过连续的运算（基于函数）得到最终结果。基于Lambda演算的被归为函数式，在众多的函数式编程语言里，Scala的血缘继承自ML 和Haskell 最多。关于ML有本非常好的书《ML for the Working Programmer》，这本书里面提到:“函数式程序是跟值打交道的，而不是跟状态打交道的。它们的工具是表达式，而不是命令。” 另外在各式各样的blog中看到的最多的就是 函数是头等公民 个人理解函数式编程就是把计算机中的运算抽象为数学中的运算，程序中的函数和方法抽象为数学中的函数，如1234567def f(x: Int):Int = &#123; 3X + 1&#125;对应于数学中的f(X) = 3X + 1 函数的参数即为数学函数中的未知数(x或y等等)，整个运算过程封装在函数体中，并且不需要依赖除了参数外的其他数据，运算完成后返回运算的结果 函数式编程的特性]]></content>
      <categories>
        <category>scala</category>
      </categories>
      <tags>
        <tag>scala</tag>
        <tag>函数式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scala学习资料整理]]></title>
    <url>%2F2018%2F07%2F21%2Fscala%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[基础twitter scala school Scala课堂是Twitter启动的一系列讲座，用来帮助有经验的工程师成为高效的Scala 程序员twitter - Effective Scala Twitter的Scala最佳实践 优质blog王宏江scala系列 持续更新中…]]></content>
      <categories>
        <category>scala</category>
      </categories>
      <tags>
        <tag>scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub Pages + Hexo搭建博客汇总]]></title>
    <url>%2F2018%2F07%2F13%2Fhexo_github_pages%2F</url>
    <content type="text"><![CDATA[网上关于GitHub Pages + Hexo搭建博客的教程较多，因此此文旨在查缺补漏，记录整个流程，汇总一些参考的优质blog，以及梳理我在搭建过程中遇到的问题。 如何搭建个人blog在开始之前，我先想了下如何搭建个人blog。既然blog是个网站，那么首先能想到的是，需要自己开发一个网站出来啊，有了网站，还需要服务器来部署我们的网站，然后还需要一个域名，方便访问我们的网站。 因此我们要做的工作有 开发自己的网站（网站设计，UI开发，评论统计系统集成维护等） 搭建服务器（部署网站，维护等） 购买域名（绑定域名） 首先开发网赚需要耗费巨大精力，其次购买服务器和域名都需要花钱，而我的初衷只是写blog啊，然而却需要做这么多，那岂不是舍本逐末了。好在已经有现成且免费的框架和工具，GitHub Pages和Hexo帮我们做了上面几乎所有的事儿 GitHub Pages介绍GitHub Pages是Github提供的一个免费静态网站的托管服务，旨在直接从GitHub仓库托管个人/组织/项目的页面，并且为站点提供了默认域名github.io。也就是说GitHub Pages帮我们解决了 服务器和域名 这两大难题 详细介绍：GitHub Pages官网 Hexo介绍Hexo是一款基于Node.js的静态博客框架。通过Hexo，用户可以定制自己喜欢的网站主题，专注与使用Markdown编写blog，它会帮用户生成静态网站并托管在GitHub，相当的简便。因此Hexo帮我们解决了 开发网站 的难题 详细介绍：Hexo中文文档 搭建个人blog的流程在使用Hexo极力推荐阅读 Hexo中文文档 ,文档里的说明要比许多blog里清晰的多 搭建前的准备工作安装流程在上文中的Hexo中文文档里有详细说明 安装Git 安装Node.js 安装Hexo 搭建流程这里只列出简单流程，定制主题，及git分支设置在后面介绍 GitHub上创建新仓库，仓库名为 GitHub用户名.github.io 这里需要注意，仓库的名字必须为上面的格式，否则部署后将无法访问blog GitHub新建分支hexo，并设置为默认分支 使用Git克隆新建仓库到本地（此时为hexo分支） 1$ git clone https://github.com/github_user_name/github_user_name.github.io.git 在仓库根目录使用hexo init命令初始化（此时为hexo分支） 1$ hexo init 上一步完成后依次使用hexo g 与 hexo s（此时为hexo分支），其中g为generator，s为server 12$ hexo g$ hexo s 打开浏览器输入localhost:4000查看本地blog效果，如下图 修改仓库根目录下的_config.yml文件，修改deploy中的以下字段并保存，注意branch要设置为master 1234deploy: type: git repo: https://github.com/github_user_name/github_user_name.github.io.git branch: master 提交本地变更至hexo分支 123$ git add .$ git commit -m 'commit msg'$ git push origin hexo 使用hexo d命令完成blog部署 1$ hexo s blog目录结构在上面流程的第4步中，执行完hexo init命令后，会在文件夹下生成hexo工程，以下简要展示生成的目录结构及各个目录的作用，更为详细的解释见Hexo目录结构123456789|-- _config.yml // 网站全局配置文件，详细说明见|-- package.json //|-- scaffolds //|-- source // 网站资源文件夹，存放网站图片，文章等 |-- _drafts |-- _posts // 我们的Markdown和HTML文件存放在次文件夹|-- themes |-- landscape // 官方默认的主题 |-- next // next主题 经过第4步之后，通过修改_config.yml文件进行网站的配置,如网站title，author等，详情见Hexo网站配置。其中最应该注意的是deploy字段，该字段用于配置网站的部署，如网站部署到git的xxx仓库的xxx分支，或是地址为xxx.xxx.xxx.xxx的服务器，详情见Hexo deploy 设置主题Hexo允许用户自定义主题，下面展示主题的设置方式 挑选自己喜欢的主题，找到其仓库地址 命令行cd 定位到themes文件夹，将主题clone至该文件夹 12$ cd themes$ git clone &lt;theme repo&gt; 在clone完成后，新添加的文件夹名称即为主题名称xxx，打开_config.yml将theme字段的landscape修改为xxx 关于主题的挑选，如果没有web前段经验，最好挑选那些star数计较高，社区比较活跃，经常迭代维护的主题，如我自己使用的next主题，下面是我在挑选主题时参考的资料 知乎-有哪些好看的Hexo主题 高赞回答用python爬虫爬出来的主题star排行榜 ,推荐参考这个挑选主题 官方主题列表 官方没有对主题进行排名，挑选时稍微麻烦些 推荐NexT主题 NexT主题外观比较简洁利落，并且社区活跃，有详尽的中文文档，主题的外观也可进行各种灵活的配置，是前段盲的必备良药。对于该主题的详细用法，其官方文档中有详细的说明，也就不再赘述了 关于git仓库的说明在搭建流程中的前两步，建立完仓库后，又新建了一个hexo分支，并且设置为默认分支。这是因为我们在维护我们的网站时，要维护以下两部分内容 Hexo工程 1hexo init之后生成的部分 生成的静态网站 1之前在_config.yml中配置了deploy的git仓库及分支，这里我配置的是master分支，在执行了hexo deploy命令之后，Hexo就会生成静态静态网站提交至master分支并自动部署 这两部分都需要提交至git仓库的，第一部分提交至git，我们就可以随时随地只要有电脑网络就可以clone工程，写blog并更新网站。第二部分是GitHub Pages部署网站必须的部分。这两部分的内容互不相干，因此建议新建hexo分支，用于存储我们的Hexo工程，master分支用于部署网站 参考的文档：知乎-使用Hexo，如果换了电脑怎么更新博客 关于NexT主题个人签名不显示的问题在NexT主题配置文件_config.yml中，如果设置seo字段为true，则网站配置文件_config.yml中的description字段会被用于seo，而不会显示为签名，这时如果想要显示个人签名，需要额外添加signature字段1signature: 随行、随记 Hexo SEO优化辛辛苦苦搭好了blog，写了文章，最后发现浏览器里搜不到啊，根本没人看啊，怎么办啊，好没有成就感。这时候就需要SEO出马了，那么什么是SEO呢？ SEO 英文全称Search Engine Optimization 即搜索引擎优化。是一种利用搜索引擎规则提高网站在有关引擎内的自然排名 既然是针对搜索引擎的优化，那么也就是针对Baidu和Google的优化了。相关blog有很多，并且都是死套路，所以这里就挑选几篇比较新比较好的blog列出来 Hexo博客Next主题SEO优化方法Hexo个人博客SEO优化系列]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub Pages</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F07%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
