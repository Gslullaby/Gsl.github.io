<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[BIP 32]]></title>
    <url>%2F2018%2F09%2F27%2Fbip32%2F</url>
    <content type="text"><![CDATA[此篇为BIP 32的译文，介绍分层确定性钱包原文链接 概述本文介绍分层确定性钱包（HD Wallet）：一种可以在不同系统间部分或全部共享，有或没有花费的能力的钱包 该规范旨在为可在不同客户端之间通信的确定性钱包设定标准。虽然本文描述的钱包有很多特性，但对于钱包客户端来说并不是每个特性都需要实现 本文分为两部分 第一部分主要介绍如何从单一种子派生出一颗秘钥树 第二部分主要介绍如何利用派生出来的秘钥树构建钱包 动机非确定性钱包的缺点现有的一些Bitcoin客户端使用随机生成的秘钥，为了避免为每笔交易后都进行备份，这些客户端会创建一个（默认）包含100个秘钥的秘钥池。并且这种钱包很难跨系统共享，或者多端同时使用。虽然可以使用钱包的加密特性隐藏私钥并且不共享密码，但是这也导致钱包失去了生成公钥的能力。 确定性钱包及非确定钱包确定性钱包不需要如此高频率的备份，而且由于椭圆曲线的数学特性，他可以在不暴露私钥的情况下计算出公钥。该特性就当于一个网络商店商家可以让他的服务器为每个顾客或每笔订单都生成一个新地址（即公钥hash），并且服务器不需要获取私钥。然而，确定性钱包只有一条密钥对链组成。这个事实意味着钱包只能全部共享或不共享两种选择。但是在某些场景下我们只希望共享部分密钥（如只共享公钥）。还是拿网络商店举例，网络服务器并不需要访问商户的所有公钥，他们只需要获取用于接受客户付款的地址对应的公钥，而不是商户消费时生成的找零地址。而分层确定性钱包支持从单一root多条密钥链的特性，使得选择性的分享成为了可能。 密钥生成规范约定在本文的其余部分，我们将假定比特币中使用的公钥加密算法，即为secp256k1定义的字段和曲线参数椭圆曲线加密算法。变量如下 整数模数曲线顺序（用n表示） 曲线上点的坐标 字节序列另外两个坐标的加法（+）定义为EC组操作的应用级联（||）是把一个字节序列附加到另一个字节序列的操作 作为标准的转换函数，我们假设 point(t):返回secp256k1基点与EC点做乘法（重复应用EC组操作）得到的坐标对与整数p。 ser32(i):把一个32位的无符号整数序列化为一个4字节序列，高位在前 ser256(p):把一个整数序列化为一个32字节序列，高位在前 serP(P):使用SEC1的压缩格式将坐标对p(x,y)序列化为字节序列：(0x02 or 0x03) || ser256(x),其中头部字节为y坐标的奇偶校验 parse256(p):将32字节序列转化为一个256位数字，高位字节优先 扩展密钥接下来，我们顶一个一个函数，该函数可以从一个给定的父密钥派生出一定数量的子密钥。为了防止派生密钥仅依赖父密钥本身，我们会额外加入一个256位的熵对私钥与公钥进行扩展。熵称之为链码，链码对于相应的公私钥是相同的，都为32字节我们把一个扩展私钥表示为(k,c)，k为普通私钥，c为256位的熵。扩展公钥表示为(K,c)，其中K=point(k)，c为256位的熵每个扩展密钥有231个普通子密钥，以及231个强化子密钥，每个密钥都有一个下标。普通密钥的下标为0 - 231-1，强化密钥的下标为231 - 232-1，为了方便，我们使用i(H)来标记强化密钥，iH = i + 231 子密钥派生函数（CKD：child key derivation）给定一个父扩展密钥及其下标i，可以计算出相应的子扩展密钥，算法取决于子扩展密钥是否是一个强化密钥（或即i是否&gt;=2^31），以及我们是否在讨论私钥或公钥 父私钥 -&gt; 子私钥函数CKDpriv((kpar, cpar), i) &rarr; (ki, ci) 判断下标i是否大于等于231，如果满足则为强化子密钥，计算I = HMAC-SHA512(Key = cpar, Data = 0x00 || ser256(kpar) || ser32(i))（注意：0x00为填充字节，保证私钥长度为33字节），如果不满足则为普通子密钥，计算I = HMAC-SHA512(Key = cpar, Data = serP(point(kpar)) || ser32(i)) 将I分为两个32字节序列，IL和IR 返回的子密钥ki = parse256(IL) + kpar (mod n) 链码(熵)ci为IR 在parse256(IL) ≥ n 或 ki = 0的情况下，生成的密钥是无效的，这时应该继续计算下一个子密钥(发生的概率小于 1/2127) HMAC-SHA512函数，可查看RFC 4231 父公钥 -&gt; 子公钥函数CKDpub((Kpar, cpar), i) &rarr; (Ki, ci)，仅适用于普通子密钥 判断下标i是否大于等于231，如果满足则返回失败，如果不满足则为普通子密钥，计算I = HMAC-SHA512(Key = cpar, Data = serP(Kpar) || ser32(i)) 将I分为两个32字节序列，IL和IR 返回的子密钥ki = point(parse256(IL)) + Kpar 链码(熵)ci为IR 在parse256(IL) ≥ n 或 Ki是无穷远的一个点时，这时应该继续计算下一个子密钥 父私钥 -&gt; 子公钥函数N((k, c)) &rarr; (K, c)计算出与扩展私钥相对应的扩展公钥 返回值K = point(k) 返回链码(熵)c即为函数输入中传递过来的链码 两种通过父私钥计算子公钥的方法 N(CKDpriv((kpar, cpar), i))(适用于任何条件) CKDpub(N(kpar, cpar), i)（仅适用于生成普通子公钥） 父公钥 -&gt; 子私钥不可能 密钥树下一步我们使用若干个CKD结构构建一颗密钥树。从单一根节点开始，即主密钥m，对多个i计算CKDpriv(m,i)，进而得到1级派生子密钥。由于派生出来的密钥也都是扩展密钥，所以CKDpriv也可以应用于这些密钥。 为了方便书写，我们把CKDpriv(CKDpriv(CKDpriv(m,3H),2),5)简写为m/3H/2/5，同样的，对于公钥，我们把CKDpub(CKDpub(CKDpub(M,3),2),5)简写为M/3/2/5。因此有了下面的等式 N(m/a/b/c) = N(m/a/b)/c = N(m/a)/b/c = N(m)/a/b/c = M/a/b/c. N(m/aH/b/c) = N(m/aH/b)/c = N(m/aH)/b/c. 但是，N(m/aH)不能写为N(m)/aH，因为我们无法通过父扩展公钥计算出子扩展私钥 每个叶子节点都对应于一个真正的密钥，叶子节点的链码会被忽略，只有节点中的公私钥是有用的。因为这种结构，我们有了父扩展私钥，就可以计算出所有的子扩展公钥及子扩展私钥，知道了父扩展公钥，就可以计算出所有的非强化子扩展公钥 密钥id可以使用序列化的ECDSA公钥的Hash160作为扩展密钥的id，忽略链码。id对应于比特币中地址。不建议使用Base58对id进行编码，因为id可能被作为地址（并且钱包软件不需要接受对链密钥本身的付款）。 密钥id的钱32位称为指纹 扩展密钥序列化格式扩展公钥及扩展私钥格式如下 4byte：版本号(主网: 0x0488B21E public, 0x0488ADE4 private; 测试网: 0x043587CF public, 0x04358394 private) 1byte：深度，根节点：0x00，一级节点：0x01 以此类推 4byte：父密钥的指纹(主密钥为0x00000000) 4byte：子节点个数(这里的英文看不懂 T T) 32byte：链码 33byte：原生公私钥数据(公钥部分为serP(K)，私钥部分为0x00 || ser256(k)) 这78byte的数据可以像比特币其他数据一样使用Base58进行编码，首先要添加32位的校验码(通过两次SHA-256生成)，然后转为Base58编码格式，编码后输出长度为112位的字符串。版本号部分经过Base58编码，对应的字符串为，主网：xprv、xpub，测试网：tprv、tpub 注意：上面格式中父密钥的指纹仅为了方便软件(钱包)检测父子节点使用，并且软件需要处理冲突，在内部，可以使用完整的160位id。 在导入序列化扩展公钥时，必须验证公钥数据中的X坐标是否存在于椭圆曲线上。 如果不是，则扩展公钥无效 主密钥生成可能的扩展密钥对总数几乎为2512，但是生成出来的密钥为256位，所以安全性会折半。主密钥并不是直接生成的，而是使用已有的种子代替。主密钥生成步骤如下： 使用prng算法生成种子序列S，长度为128 - 512位之间。建议使用256位 计算I = HMAC-SHA512(Key = “Bitcoin seed”, Data = S)，直接使用比特币种子作为输入 将I分为两个32字节序列，IL and IR 使用parse256(IL)作为主私钥，IR作为主链码 在IL = 0 或 ≥n的情况下，生成的主密钥无效，需要重新生成 分层确定性钱包结构前面的部分中描述了密钥树及其节点，下一步是在此基础上构建一个钱包。本文中介绍的仅为一种范例，但是建议开发者开发钱包时模仿范例的兼容性，但也不是所有的功能都需要支持 范例钱包的结构一个HDW可以看做一系列账户的集合，每个账户都有个编号，默认账户account(“”)的编码为0。钱包可以不支持多账户，如果不支持，则使用默认账户。 每个账户都是两条密钥链组成：内部链，外部链。外部链用来生成新的公共钱包地址，内部链可用于所有其他的操作(更改地址，生成地址，可以是任何不需要通信的操作)，支持双密钥链的钱包，应该使用外部链以支持所有的操作 m/iH/0/k 为从主密钥m导出的第i个账号的外部链的第k个密钥对 m/iH/1/k 为从主密钥m导出的第i个账号的内部链的第k个密钥对 用例全钱包共享在两个系统需要访问同一个钱包，并且两个系统都需要有花费的功能，则需要共享主扩展私钥。每个网络节点需要为外部链维护一个前瞻密钥缓池，其中保存n个前瞻密钥，用于监听收到的付款。对内部内部链的展望可能非常小，因为不存在任何缺口。注意账户名无法通过区块链同步，仍然需要手动输入。 审计如果一名审计员需要获取所有交易(收支)记录，则可以将所有账户的扩展公钥共享给审计员。这样审计员就可以查看当前钱包的所有交易(收支)了 公司多部门场景当一家公司拥有数个独立的部门，则这些部门可以使用从同一主密钥派生出来的钱包。进而公司的领导通过维护一个超级钱包，就可以看到各个部门的收支情况了，甚至可以在各部门之间转移资金 合作企业间交易可以使用特定账户的外部链的扩展公钥作为“超级地址”，可以使得即使高频交易也不容易被别人追踪到，但无需为每笔付款都申请一个新地址。矿池操作员也可以使用这种机制作为可变支付地址 不安全的收款人当运行电子商务的服务器，存在安全风险时，他需要知道用于收款的公共地址。服务器只需要知道单个账户外部链扩展公钥。这意味着非法访问网络服务器的人最多只能查看交易记录，但是无法盗取资金，如果存在多台服务器，则他只攻破一台服务器，也无法访问到其它服务器的交易记录]]></content>
      <tags>
        <tag>区块链</tag>
        <tag>BIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BIP 39]]></title>
    <url>%2F2018%2F09%2F13%2Fbip39%2F</url>
    <content type="text"><![CDATA[进入区块链行业已经一年有余，开发之余也一直在补充区块链知识，读过《区块链-技术驱动金融》，以及BTC白皮书BIP等，记录的比较零散，很有必要整理一下。首先先把比较重要的BIP翻译整理一遍。此篇BIP39的译文，是助记词相关知识 原文链接 概要此篇BIP介绍如何为确定性钱包生成助记词或者助记句（一组容易记忆的单词）本文包括两部分： 生成助记词 将助记词转化为二进制种子。种子可以用于生成BIP 32中所描述的确定性钱包 动机原生的二进制信息/十六进制的钱包种子，对人们来说是很难记录并保存的，而且在保存的过程中也容易出错。如果换成一组单词或句子，则友好的多。句子可以很方便的写在纸上或其他隐秘的地方 生成助记词第一步 – 生成初始熵熵的位数必须为32的整数倍。熵越长，越安全，相应的助记词也就越多。这里定位熵的长度为ENT，ENT的取值范围为128位-256位 第二步 – 计算校验和计算方式，对初始熵计算SHA256 hash，取其前 ENT/32 位作为校验和CS。 第三部 – 生成助记词然后将校验和拼接在初始熵的尾部，即ENT+CS位数据，再划分为整数个11bit组，即（ENT+CS）/ 11组，记为MS，每个组可以编码为0-2047中的一个正整数，刚好对应于助记词表中的一个单词的下标。然后将分组按照下标转换为一组助记词 下图描述了ENT，CS，MS的关系 助记词表一个理想的助记词表应该拥有以下特性 选词聪明 所选的词应该满足通过单词的前四个字符就可以确定该单词 避免相近次出现 如’build’/‘built’、’woman’/‘women’、’quick’/‘quickly’。这类相似词，不仅让记忆句子变得困难，而且也更容易出错 助记词列表需要排序 有序的助记词列表，可以让词查找更加有效率，同时也可以使用前缀树，以便更好的压缩 注：助记词表可以包含本地字符，但是必须使用（NFKD）UTF-8编码 助记词转化为种子（seed）有些用户可能想用passphrase对助记词进行加密。如果没有设置passphrase则使用“”空字符代替生成种子使用的是PBKDF2算法该算法的该算法的输入为 助记词作为password参数 “mnemonic”+passphrase作为salt参数 迭代次数设置为2048 使用HMAC-SHA512作为伪随机数生成函数 输出为 512位的种子 种子用于生成BIP 32中描述的确定性钱包（HD Wallet） 由于seed的生成完全独立于mnemonic的生成，这使得代码非常简洁。并且对助记词没有任何限制，用户可以实现自己的单词表，甚至是整个助记词的生成 虽然可以使用其他算法生成的助记符，但不建议这样做，并且APP中必须使用助记词表计算助记词的校验和，如果无效则应该提示用户。 注：错误的passphrase虽然也能生成有效的seed，并且生成钱包，但只有正确的passphrase生成的seed，才能获取到拥有财产的钱包]]></content>
      <tags>
        <tag>区块链</tag>
        <tag>BIP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scala中的函数]]></title>
    <url>%2F2018%2F07%2F23%2Fscala%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[在各类blog及scala书籍中看到的关于函数最多的一句话是 函数是一等公民 可以看出函数在scala中举足轻重的地位，因此很有必要去全面的掌握它 scala函数基础定义函数 匿名函数 12scala&gt; (x: Int) =&gt; x + 1res0: Int =&gt; Int = $$Lambda$1026/1792711692@7412ed6b 固定写法：左边是参数列表，中间符号=&gt;，右边是函数体匿名函数无函数名，也无需给出函数的结果类型 函数字面量 123scala&gt; val f = (x: Int) =&gt; x + 1scala&gt; f(10)res0: Int = 11 其中表达式有半部分为一个匿名函数，函数作为一个变量(或不变量)，用变量名+参数表方式调用，与普通方法的调用几乎相同。 需要注意的是函数字面量声明函数时不需要写出函数的返回值类型，函数体的最后一条表达式的结果会作为返回值返回 函数值函数字面量与函数值的关系就像类与对象的关系。函数字面量其实就是一个实现了trait Function*的函数类，在运行时实例化了一个函数类，这个实例就是函数值 函数的本质scala不像java有基本类型与引用类型之分，scala中一切皆对象，包括函数也是对象。scala中定义了一系列trait，Function0 - Function22，其中0-22表示参数的个数(至于为什么是到22，理论上讲程序中不会出现多于22个参数的函数)。而函数正是Function的实例。如val f = (x: Int) =&gt; x + 1其实就是Function1的实例。下面看下Function的源码，以Function3为例123456789101112131415161718192021222324252627/** A function of 3 parameters. * */trait Function3[-T1, -T2, -T3, +R] extends AnyRef &#123; self =&gt; /** Apply the body of this function to the arguments. * @return the result of function application. */ def apply(v1: T1, v2: T2, v3: T3): R /** Creates a curried version of this function. * * @return a function `f` such that `f(x1)(x2)(x3) == apply(x1, x2, x3)` */ @annotation.unspecialized def curried: T1 =&gt; T2 =&gt; T3 =&gt; R = &#123; (x1: T1) =&gt; (x2: T2) =&gt; (x3: T3) =&gt; apply(x1, x2, x3) &#125; /** Creates a tupled version of this function: instead of 3 arguments, * it accepts a single [[scala.Tuple3]] argument. * * @return a function `f` such that `f((x1, x2, x3)) == f(Tuple3(x1, x2, x3)) == apply(x1, x2, x3)` */ @annotation.unspecialized def tupled: Tuple3[T1, T2, T3] =&gt; R = &#123; case Tuple3(x1, x2, x3) =&gt; apply(x1, x2, x3) &#125; override def toString() = "&lt;function3&gt;"&#125; 可以看到其中有一个apply方法(先忽略其他方法)，接受三个泛型参数，所以当我们调用f(1)时，其实是调用了Function1实例的apply方法。 函数与方法在学习过程中，还有一点很困扰，就是我们在类中用def定义的是不是函数，如果不是函数，它又是什么，跟函数又有什么区别呢？首先呢使用def 关键字定义的是方法，不是函数，虽然在实际应用中几乎没有差别，但还是需要了解两者的不同的 方法 定义在类中，作为某个对象的成员方法，使用def关键字定义12scala&gt; def a(x: Int):Int = x + 1a: (x: Int)Int 两者的区别 方法使用def关键字定义，而函数不用(函数使用val/var或干脆匿名) 方法是类的一部分，函数是对象可以赋值给一个val/var 函数作为对象可以像任何其他数据类型一样被传递和操作，而方法不行，如果想要传递方法，则需要把方法转换为函数 定义方法时，如果没有参数，则参数表可以省略不写(即方法名后不写())，而函数不行 定义函数时参数列表后不能声明结果类型，如下面的写法会编译错误1234scala&gt; f(x: Int):Int =&gt; x + 1&lt;console&gt;:1: error: ';' expected but '=&gt;' found. f(x: Int):Int =&gt; x + 1 ^ 两者的转换 第一种情况，方法直接转为函数不能将方法直接声明为一个val/var，如下面的写法会编译错误 123456scala&gt; def m(x: Int):Int = x + 1scala&gt; val f = m&lt;console&gt;:12: error: missing argument list for method mUnapplied methods are only converted to functions when a function type is expected.You can make this conversion explicit by writing `m _` or `m(_)` instead of `m`. val f = m 正确写法 123scala&gt; def m(x: Int):Int = x + 1scala&gt; val f = m _f: Int =&gt; Int = $$Lambda$1069/727861082@4990b335 这个转换的其实是使用了部分应用(Partial Applied Function)，下面将会讲到 第二种情况，需要函数的地方使用方法这种情况下不需要使用下划线，方法会被自动转换为函数，称之为eta转换。关于eta-expansion与eta-conversion的解释可以参考王宏江-scala中的eta-conversion与王宏江-再谈eta-conversion与eta-expansion scala函数进阶高阶函数引用维基百科中高阶函数的定义 在数学和计算机科学中，高阶函数是至少满足下列一个条件的函数： 接受一个或多个函数作为输入 输出一个函数 定义应该很容易理解，也就是函数可以接受另一个函数作为参数，或者函数的结果类型为函数类型。 第一种：如数学中的函数f(x) = x + 1， g(x) = x * 2，则f(g(x)) = (x * 2) + 1, 即为高阶函数。用代码实现即为 12def g(x: Int) = x * 2def f(x: Int, g: Int =&gt; Int) = g(x) + 1 第二种：结果类型为函数类型 1234def g(x: Int):(Int =&gt; Int) = &#123; val k = x * 2 (y: Int) =&gt; y + k + 1&#125; 函数的部分应用先看下代码如何实现函数的部分应用吧1234567891011121314scala&gt; def sum(x: Int, y: Int, z: Int) = x + y + zsum: (x: Int, y: Int, z: Int)Intscala&gt; val a = sum _a: (Int, Int, Int) =&gt; Int = $$Lambda$1055/565627330@309cedb6scala&gt; a(1,2,3)res0: Int = 6scala&gt; val b = sum(1, _: Int, _: Int)b: (Int, Int) =&gt; Int = $$Lambda$1060/605472344@6d5f4900scala&gt; b(2,3)res1: Int = 6 上面代码中出现了两种写法 写法一val a = sum _这行代码表示sum方法的三个参数都为给出，整个参数表都用占位符_代替，所以这行代码的效果其实就是讲方法sum转换为了函数a。与之相同的写法还有val a = sum(_) 写法二val b = sum(1, _: Int, _: Int)这行代码表示，已知三个参数中的x，y和z未给出，用占位符_代替，最后返回一个包含了两个参数的函数b 部分应用从数学角度理解比较容易，如上面例子中的sum，其实对应于数学中的sum(x,y,z) = x + y + z，这是一个三元函数(既有三个未知数)，而写法二对sum的部分应用，相当于我们现在得知x = 1，则带入函数得sum(y,z) = 1 + y + z，也就是函数f消去了未知元x。 整体来看函数的部分应用其实就是数学中的消元。 而写法是对未消去任何参数的一种简写 函数的柯里化在scala中函数函数可以有多个参数列表，而函数柯里化就是将函数的多参数列表转换为多个多参数列表。写法如下12345678scala&gt; def sum(x: Int, y: Int) = x + ysum: (x: Int, y: Int)Intscala&gt; val a = sum _a: (Int, Int) =&gt; Int = $$Lambda$1075/571435580@5eb041b5scala&gt; val b = a.curriedb: Int =&gt; (Int =&gt; Int) = scala.Function2$$Lambda$1076/1263872787@524dd373 柯里化是通过调用函数对象的curried方法实现的。也就是说调用的是Function*中的curried方法(Function2-Function22拥有curried方法，Function0及Function1没有，因为无参函数和但参函数不需要也不能柯里化)，以Function2为例，我们看下源码的实现1234567trait Function2[-T1, -T2, +R] extends AnyRef &#123; self =&gt; ... @annotation.unspecialized def curried: T1 =&gt; T2 =&gt; R = &#123; (x1: T1) =&gt; (x2: T2) =&gt; apply(x1, x2) &#125; ...&#125; curried的实现是将一个多参函数转换为一个单参函数的函数链，对于上面的例子来说就是把sum(x,y)转换成了sum(x)(y)，sum(1)(2)也就是对两个单参函数的依次调用，而sum(1)或者sum(2)其实相当于对sum函数的部分应用，返回值是一个单参函数 闭包引用别人blog中对闭包的定义 闭包是一个函数，返回值依赖于声明在函数外部的一个或多个变量。 示例12345scala&gt; var more = 1more: Int = 1scala&gt; val add = (i: Int) =&gt; i + moreadd: Int =&gt; Int = $$Lambda$1045/640294829@6be6931f 上面例子中add函数的计算依赖于自由变量more，也就是闭包了。闭包很像函数字面量，不同的是，闭包运算的过程不只依赖于输入参数，还需要依赖函数之外的一个或多个自由变量。 关于闭包的详细解释可以参考知乎-什么是闭包，引用博文中的总结 最简洁、直击要害的回答，我能想到的分别有这么三句（版权属于 ： 闭包是一个有状态（不消失的私有数据）的函数。 闭包是一个有记忆的函数。 闭包相当于一个只有一个方法的紧凑对象（a compact object）。 上面这三句话是等价的 嵌套函数scala允许在函数内部定义函数，称之为局部函数。它的作用域仅限于外部函数，其他位置无法访问到内部函数，可以达到控制访问的效果示例1234val f = (x:Int) =&gt; &#123; val innerAdd = (i: Int) =&gt; i + 1 innerAdd(x) + 1&#125; 写在最后关于scala中的函数，就先写这么多吧，等到后面开发应用到其他的知识，在作补充。关于函数的部分应用和柯里化的实际意义，在scala函数式编程那篇里写出来，这里就不写了]]></content>
      <categories>
        <category>scala</category>
      </categories>
      <tags>
        <tag>scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scala函数式编程]]></title>
    <url>%2F2018%2F07%2F21%2Fscala%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[从java转向scala已经有一段时间了，虽然平时写代码问题不大，但是因为面向对象编程已经根深蒂固了，一直对函数式编程理解不是很到位，scala虽然是多范式编程语言，但是官方还是鼓励开发者使用函数式编程的，所以很有必要仔细学习并记录一下 什么是函数式函数式编程，不是某一种语言的特性，而是诸多编程思想(如命令式，面向对象等)中的一种。对于它的解释，引用王宏江-Scala中的函数式特性中的一段话 图灵机，以及冯诺依曼对它的实现（冯诺依曼体系），从风格上被归为“命令式”，它的运算过程可以看作不断地修改内存来反映运算的结果，即用命令修改状态；而阿隆佐邱奇提出的 Lambda 演算，则是通过连续的运算（基于函数）得到最终结果。基于Lambda演算的被归为函数式，在众多的函数式编程语言里，Scala的血缘继承自ML 和Haskell 最多。关于ML有本非常好的书《ML for the Working Programmer》，这本书里面提到:“函数式程序是跟值打交道的，而不是跟状态打交道的。它们的工具是表达式，而不是命令。” 表达式上面引文里，函数式程序的工具是表达式，那么什么是表达式呢？表达式可以简单理解为有返回值的语句。在scala中只有表达式，因为在scala中任何语句都有返回值，而在java中则不是。如赋值语句在scala中是有返回值的，返回类型为Unit，而在java中赋值语句没有返回值示例12345scala&gt; var b = 1b: Int = 1scala&gt; val a = b = 3a: Unit = () 变量b被重新赋值为3，赋值的结果类型为Unit，并且赋值给了a 个人理解函数式编程就是把计算机中的运算抽象为数学中的运算，程序中的函数和方法抽象为数学中的函数。如1234567def f(x: Int):Int = &#123; 3X + 1&#125;对应于数学中的f(X) = 3X + 1 函数的参数即为数学函数中的未知数(x或y等等)，整个运算过程封装在函数体中，并且不需要依赖除了参数外的其他数据，运算完成后返回运算的结果。 对于复杂的运算，抽象为多个函数的嵌套调用，整个运算的过程都是围绕函数进行的，摒弃了命令式编程中对状态的依赖，这也是为什么scala鼓励我们使用val不变量，而尽量少使用var变量 最终整个应用程序都是由一个一个的函数组成 为了支持函数式编程，scala中提供了很多函数特性，这些特性在scala中的函数那篇blog里，简单罗列下 引入了与其他类型地位平等的函数类型，函数可传递，可作为返回值 对高阶函数的支持 函数的部分应用 函数柯里化 函数嵌套 闭包 函数式编程的特性关于函数式编程的特性可以参考阮一峰-函数式编程初探]]></content>
      <categories>
        <category>scala</category>
      </categories>
      <tags>
        <tag>scala</tag>
        <tag>函数式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scala学习资料整理]]></title>
    <url>%2F2018%2F07%2F21%2Fscala%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[基础twitter scala school Scala课堂是Twitter启动的一系列讲座，用来帮助有经验的工程师成为高效的Scala 程序员twitter - Effective Scala Twitter的Scala最佳实践 优质blog王宏江scala系列**李浩毅blog 集合Scala中的集合Why scala.collection.Traversable Is Bad Design Scala Collection的性能(李浩毅blog的译文) 零散Scala中的下划线 持续更新中…]]></content>
      <categories>
        <category>scala</category>
      </categories>
      <tags>
        <tag>scala</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub Pages + Hexo搭建博客汇总]]></title>
    <url>%2F2018%2F07%2F13%2Fhexo_github_pages%2F</url>
    <content type="text"><![CDATA[网上关于GitHub Pages + Hexo搭建博客的教程较多，因此此文旨在查缺补漏，记录整个流程，汇总一些参考的优质blog，以及梳理我在搭建过程中遇到的问题。 如何搭建个人blog在开始之前，我先想了下如何搭建个人blog。既然blog是个网站，那么首先能想到的是，需要自己开发一个网站出来啊，有了网站，还需要服务器来部署我们的网站，然后还需要一个域名，方便访问我们的网站。 因此我们要做的工作有 开发自己的网站（网站设计，UI开发，评论统计系统集成维护等） 搭建服务器（部署网站，维护等） 购买域名（绑定域名） 首先开发网赚需要耗费巨大精力，其次购买服务器和域名都需要花钱，而我的初衷只是写blog啊，然而却需要做这么多，那岂不是舍本逐末了。好在已经有现成且免费的框架和工具，GitHub Pages和Hexo帮我们做了上面几乎所有的事儿 GitHub Pages介绍GitHub Pages是Github提供的一个免费静态网站的托管服务，旨在直接从GitHub仓库托管个人/组织/项目的页面，并且为站点提供了默认域名github.io。也就是说GitHub Pages帮我们解决了 服务器和域名 这两大难题 详细介绍：GitHub Pages官网 Hexo介绍Hexo是一款基于Node.js的静态博客框架。通过Hexo，用户可以定制自己喜欢的网站主题，专注与使用Markdown编写blog，它会帮用户生成静态网站并托管在GitHub，相当的简便。因此Hexo帮我们解决了 开发网站 的难题 详细介绍：Hexo中文文档 搭建个人blog的流程在使用Hexo极力推荐阅读 Hexo中文文档 ,文档里的说明要比许多blog里清晰的多 搭建前的准备工作安装流程在上文中的Hexo中文文档里有详细说明 安装Git 安装Node.js 安装Hexo 搭建流程这里只列出简单流程，定制主题，及git分支设置在后面介绍 GitHub上创建新仓库，仓库名为 GitHub用户名.github.io 这里需要注意，仓库的名字必须为上面的格式，否则部署后将无法访问blog GitHub新建分支hexo，并设置为默认分支 使用Git克隆新建仓库到本地（此时为hexo分支） 1$ git clone https://github.com/github_user_name/github_user_name.github.io.git 在仓库根目录使用hexo init命令初始化（此时为hexo分支） 1$ hexo init 上一步完成后依次使用hexo g 与 hexo s（此时为hexo分支），其中g为generator，s为server 12$ hexo g$ hexo s 打开浏览器输入localhost:4000查看本地blog效果，如下图 修改仓库根目录下的_config.yml文件，修改deploy中的以下字段并保存，注意branch要设置为master 1234deploy: type: git repo: https://github.com/github_user_name/github_user_name.github.io.git branch: master 提交本地变更至hexo分支 123$ git add .$ git commit -m 'commit msg'$ git push origin hexo 使用hexo d命令完成blog部署 1$ hexo s blog目录结构在上面流程的第4步中，执行完hexo init命令后，会在文件夹下生成hexo工程，以下简要展示生成的目录结构及各个目录的作用，更为详细的解释见Hexo目录结构123456789|-- _config.yml // 网站全局配置文件，详细说明见|-- package.json //|-- scaffolds //|-- source // 网站资源文件夹，存放网站图片，文章等 |-- _drafts |-- _posts // 我们的Markdown和HTML文件存放在次文件夹|-- themes |-- landscape // 官方默认的主题 |-- next // next主题 经过第4步之后，通过修改_config.yml文件进行网站的配置,如网站title，author等，详情见Hexo网站配置。其中最应该注意的是deploy字段，该字段用于配置网站的部署，如网站部署到git的xxx仓库的xxx分支，或是地址为xxx.xxx.xxx.xxx的服务器，详情见Hexo deploy 设置主题Hexo允许用户自定义主题，下面展示主题的设置方式 挑选自己喜欢的主题，找到其仓库地址 命令行cd 定位到themes文件夹，将主题clone至该文件夹 12$ cd themes$ git clone &lt;theme repo&gt; 在clone完成后，新添加的文件夹名称即为主题名称xxx，打开_config.yml将theme字段的landscape修改为xxx 关于主题的挑选，如果没有web前段经验，最好挑选那些star数计较高，社区比较活跃，经常迭代维护的主题，如我自己使用的next主题，下面是我在挑选主题时参考的资料 知乎-有哪些好看的Hexo主题 高赞回答用python爬虫爬出来的主题star排行榜 ,推荐参考这个挑选主题 官方主题列表 官方没有对主题进行排名，挑选时稍微麻烦些 推荐NexT主题 NexT主题外观比较简洁利落，并且社区活跃，有详尽的中文文档，主题的外观也可进行各种灵活的配置，是前段盲的必备良药。对于该主题的详细用法，其官方文档中有详细的说明，也就不再赘述了 关于git仓库的说明在搭建流程中的前两步，建立完仓库后，又新建了一个hexo分支，并且设置为默认分支。这是因为我们在维护我们的网站时，要维护以下两部分内容 Hexo工程 1hexo init之后生成的部分 生成的静态网站 1之前在_config.yml中配置了deploy的git仓库及分支，这里我配置的是master分支，在执行了hexo deploy命令之后，Hexo就会生成静态静态网站提交至master分支并自动部署 这两部分都需要提交至git仓库的，第一部分提交至git，我们就可以随时随地只要有电脑网络就可以clone工程，写blog并更新网站。第二部分是GitHub Pages部署网站必须的部分。这两部分的内容互不相干，因此建议新建hexo分支，用于存储我们的Hexo工程，master分支用于部署网站 参考的文档：知乎-使用Hexo，如果换了电脑怎么更新博客 关于NexT主题个人签名不显示的问题在NexT主题配置文件_config.yml中，如果设置seo字段为true，则网站配置文件_config.yml中的description字段会被用于seo，而不会显示为签名，这时如果想要显示个人签名，需要额外添加signature字段1signature: 随行、随记 Hexo SEO优化辛辛苦苦搭好了blog，写了文章，最后发现浏览器里搜不到啊，根本没人看啊，怎么办啊，好没有成就感。这时候就需要SEO出马了，那么什么是SEO呢？ SEO 英文全称Search Engine Optimization 即搜索引擎优化。是一种利用搜索引擎规则提高网站在有关引擎内的自然排名 既然是针对搜索引擎的优化，那么也就是针对Baidu和Google的优化了。相关blog有很多，并且都是死套路，所以这里就挑选几篇比较新比较好的blog列出来 Hexo博客Next主题SEO优化方法Hexo个人博客SEO优化系列]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>GitHub Pages</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F07%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
